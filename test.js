let f_qs =
[
    {
        "question": "\"\""
    },
    {
        "question": "\"\""
    },
    {
        "question": "\"Introduction to React\""
    },
    {
        "question": "\"1. What is React?\""
    },
    {
        "question": "\"2. What are the advantages of using React?\""
    },
    {
        "question": "\"3. What are the limitations of React?\""
    },
    {
        "question": "\"\""
    },
    {
        "question": "\"4. What is useState() in React?\""
    },
    {
        "question": "\"5. What are keys in React?\""
    },
    {
        "question": "\"6. What is JSX?\""
    },
    {
        "question": "\"7. What are the differences between functional and class components?\""
    },
    {
        "question": "\"8. What is the virtual DOM? How does react use the virtual DOM to render the UI?\""
    },
    {
        "question": "\"9. What are the differences between controlled and uncontrolled components?\""
    },
    {
        "question": "\"10. What are props in React?\""
    },
    {
        "question": "\"11. Explain React state and props.\""
    },
    {
        "question": "\"12. Explain about types of side effects in React component.\""
    },
    {
        "question": "\"13. What is prop drilling in React?\""
    },
    {
        "question": "\"14. What are error boundaries?\""
    },
    {
        "question": "\"15. What is React Hooks?\""
    },
    {
        "question": "\"16. Explain React Hooks.\""
    },
    {
        "question": "\"17. What are the rules that must be followed while using React Hooks?\""
    },
    {
        "question": "\"18. What is the use of useEffect React Hooks?\""
    },
    {
        "question": "\"19. Why do React Hooks make use of refs?\""
    },
    {
        "question": "\"20. What are Custom Hooks?\""
    },
    {
        "question": "\"21. Explain Strict Mode in React.\""
    },
    {
        "question": "\"22. How to prevent re-renders in React?\""
    },
    {
        "question": "\"23. What are the different ways to style a React component?\""
    },
    {
        "question": "\"24. Name a few techniques to optimize React app performance.\""
    },
    {
        "question": "\"25. How to pass data between react components?\""
    },
    {
        "question": "\"26. What are Higher Order Components?\""
    },
    {
        "question": "\"27. What are the different phases of the component lifecycle?\""
    },
    {
        "question": "\"28. What are the lifecycle methods of React?\""
    },
    {
        "question": "\"29. Does React Hook work with static typing?\""
    },
    {
        "question": "\"30. Explain about types of Hooks in React.\""
    },
    {
        "question": "\"31. Differentiate React Hooks vs Classes.\""
    },
    {
        "question": "\"32. How does the performance of using Hooks will differ in comparison with the classes?\""
    },
    {
        "question": "\"33. Do Hooks cover all the functionalities provided by the classes?\""
    },
    {
        "question": "\"34. What is React Router?\""
    },
    {
        "question": "\"35. Can React Hook replaces Redux?\""
    },
    {
        "question": "\"36. Explain conditional rendering in React.\""
    },
    {
        "question": "\"37. Explain how to create a simple React Hooks example program.\""
    },
    {
        "question": "\"38. How to create a switching component for displaying different pages?\""
    },
    {
        "question": "\"39. How to re-render the view when the browser is resized?\""
    },
    {
        "question": "\"40. How to pass data between sibling components using React router?\""
    },
    {
        "question": "\"41. How to perform automatic redirect after login?\""
    },
    {
        "question": "\"Conclusion\""
    },
    {
        "question": "\"Useful References and Resources:\""
    }
]


let f_ans =[
    {
        "answer": "\"React is a front-end and open-source JavaScript library which is useful in developing user interfaces specifically for applications with a single page. It is helpful in building complex and reusable user interface(UI) components of mobile and web applications as it follows the component-based approach.\\n\\nThe important features of React are:\\n\\nIt supports server-side rendering.\\nIt will make use of the virtual DOM rather than real DOM (Data Object Model) as RealDOM manipulations are expensive.\\nIt follows unidirectional data binding or data flow.\\nIt uses reusable or composable UI components for developing the view.\""
    },
    {
        "answer": "\"MVC is generally abbreviated as Model View Controller.\\n\\nUse of Virtual DOM to improve efficiency: React uses virtual DOM to render the view. As the name suggests, virtual DOM is a virtual representation of the real DOM. Each time the data changes in a react app, a new virtual DOM gets created. Creating a virtual DOM is much faster than rendering the UI inside the browser. Therefore, with the use of virtual DOM, the efficiency of the app improves.\\nGentle learning curve: React has a gentle learning curve when compared to frameworks like Angular. Anyone with little knowledge of javascript can start building web applications using React.\\nSEO friendly: React allows developers to develop engaging user interfaces that can be easily navigated in various search engines. It also allows server-side rendering, which boosts the SEO of an app.\\nReusable components: React uses component-based architecture for developing applications. Components are independent and reusable bits of code. These components can be shared across various applications having similar functionality. The re-use of components increases the pace of development.\\nHuge ecosystem of libraries to choose from: React provides you with the freedom to choose the tools, libraries, and architecture for developing an application based on your requirement.\""
    },
    {
        "answer": "\"The few limitations of React are as given below:\\n\\nReact is not a full-blown framework as it is only a library.\\nThe components of React are numerous and will take time to fully grasp the benefits of all.\\nIt might be difficult for beginner programmers to understand React.\\nCoding might become complex as it will make use of inline templating and JSX.\""
    },
    {
        "answer": "\"The useState() is a built-in React Hook that allows you for having state variables in functional components. It should be used when the DOM has something that is dynamically manipulating/controlling.\\n\\nIn the below-given example code, The useState(0) will return a tuple where the count is the first parameter that represents the counter’s current state and the second parameter setCounter method will allow us to update the state of the counter.\\n\\n...\\nconst [count, setCounter] = useState(0);\\nconst [otherStuffs, setOtherStuffs] = useState(...);\\n...\\nconst setCount = () => {\\n   setCounter(count + 1);\\n   setOtherStuffs(...);\\n   ...\\n};\\n\\nWe can make use of setCounter() method for updating the state of count anywhere. In this example, we are using setCounter() inside the setCount function where various other things can also be done. The idea with the usage of hooks is that we will be able to keep our code more functional and avoid class-based components if they are not required.\""
    },
    {
        "answer": "\"A key is a special string attribute that needs to be included when using lists of elements.\\n\\nExample of a list using key -\\n\\nconst ids = [1,2,3,4,5];\\nconst listElements = ids.map((id)=>{\\nreturn(\\n<li key={id.toString()}>\\n  {id}\\n</li>\\n)\\n})\\n\\nImportance of keys -\\n\\nKeys help react identify which elements were added, changed or removed.\\nKeys should be given to array elements for providing a unique identity for each element.\\nWithout keys, React does not understand the order or uniqueness of each element.\\nWith keys, React has an idea of which particular element was deleted, edited, and added.\\nKeys are generally used for displaying a list of data coming from an API.\\n\\n***Note- Keys used within arrays should be unique among siblings. They need not be globally unique.\""
    },
    {
        "answer": "\"JSX stands for JavaScript XML. It allows us to write HTML inside JavaScript and place them in the DOM without using functions like appendChild( ) or createElement( ).\\n\\nAs stated in the official docs of React, JSX provides syntactic sugar for React.createElement( ) function.\\n\\nNote- We can create react applications without using JSX as well.\\n\\nLet’s understand how JSX works:\\n\\nWithout using JSX, we would have to create an element by the following process:\\n\\nconst text = React.createElement('p', {}, 'This is a text');\\nconst container = React.createElement('div','{}',text );\\nReactDOM.render(container,rootElement);\\n\\nUsing JSX, the above code can be simplified:\\n\\nconst container = (\\n<div>\\n  <p>This is a text</p>\\n</div>\\n);\\nReactDOM.render(container,rootElement);\\n\\nAs one can see in the code above, we are directly using HTML inside JavaScript.\""
    },
    {
        "answer": "\"Before the introduction of Hooks in React, functional components were called stateless components and were behind class components on a feature basis. After the introduction of Hooks, functional components are equivalent to class components.\\n\\nAlthough functional components are the new trend, the react team insists on keeping class components in React. Therefore, it is important to know how these components differ.\\n\\nOn the following basis let’s compare functional and class components:\\n\\nDeclaration\\n\\nFunctional components are nothing but JavaScript functions and therefore can be declared using an arrow function or the function keyword:\\n\\n  function card(props){\\n   return(\\n      <div className=\\\"main-container\\\">\\n        <h2>Title of the card</h2>\\n      </div>\\n    )\\n   }\\n   const card = (props) =>{\\n    return(\\n      <div className=\\\"main-container\\\">\\n        <h2>Title of the card</h2>\\n      </div>\\n    )\\n   }\\n\\nClass components, on the other hand, are declared using the ES6 class:\\n\\n class Card extends React.Component{\\n  constructor(props){\\n     super(props);\\n   }\\n    render(){\\n      return(\\n        <div className=\\\"main-container\\\">\\n          <h2>Title of the card</h2>\\n        </div>\\n      )\\n    }\\n   }\\nHandling props\\n\\nLet’s render the following component with props and analyse how functional and class components handle props:\\n\\n<Student Info name=\\\"Vivek\\\" rollNumber=\\\"23\\\" />\\n\\nIn functional components, the handling of props is pretty straightforward. Any prop provided as an argument to a functional component can be directly used inside HTML elements:\\n\\n function StudentInfo(props){\\n   return(\\n     <div className=\\\"main\\\">\\n       <h2>{props.name}</h2>\\n       <h4>{props.rollNumber}</h4>\\n     </div>\\n   )\\n }\\n\\nIn the case of class components, props are handled in a different way:\\n\\n class StudentInfo extends React.Component{\\n   constructor(props){\\n     super(props);\\n    }\\n    render(){\\n      return(\\n        <div className=\\\"main\\\">\\n          <h2>{this.props.name}</h2>\\n          <h4>{this.props.rollNumber}</h4> \\n        </div>\\n      )\\n    }\\n   }\\n\\nAs we can see in the code above, this keyword is used in the case of class components.\\n\\nHandling state\\n\\nFunctional components use React hooks to handle state. It uses the useState hook to set the state of a variable inside the component:\\n\\n function ClassRoom(props){\\n   let [studentsCount,setStudentsCount] = useState(0);\\n    const addStudent = () => {\\n      setStudentsCount(++studentsCount);\\n   }\\n    return(\\n      <div>\\n        <p>Number of students in class room: {studentsCount}</p>\\n        <button onClick={addStudent}>Add Student</button>\\n      </div>\\n    )\\n   }\\n\\nSince useState hook returns an array of two items, the first item contains the current state, and the second item is a function used to update the state.\\n\\nIn the code above, using array destructuring we have set the variable name to studentsCount with a current value of “0” and setStudentsCount is the function that is used to update the state.\\n\\nFor reading the state, we can see from the code above, the variable name can be directly used to read the current state of the variable.\\n\\nWe cannot use React Hooks inside class components, therefore state handling is done very differently in a class component:\\n\\nLet’s take the same above example and convert it into a class component:\\n\\nclass ClassRoom extends React.Component{\\n        constructor(props){\\n            super(props);\\n            this.state = {studentsCount : 0};\\n            \\n            this.addStudent = this.addStudent.bind(this);\\n         }\\n            \\n            addStudent(){\\n            this.setState((prevState)=>{\\n               return {studentsCount: prevState.studentsCount++}\\n            });\\n         }\\n            \\n            render(){\\n             return(\\n               <div>\\n                 <p>Number of students in class room: {this.state.studentsCount}</p>\\n                 <button onClick={this.addStudent}>Add Student</button>\\n               </div>\\n             )\\n           }\\n         }  \\n\\nIn the code above, we see we are using this.state to add the variable studentsCount and setting the value to “0”.\\n\\nFor reading the state, we are using this.state.studentsCount.\\n\\nFor updating the state, we need to first bind the addStudent function to this. Only then, we will be able to use the setState function which is used to update the state. \""
    },
    {
        "answer": "\"As stated by the react team, virtual DOM is a concept where a virtual representation of the real DOM is kept inside the memory and is synced with the real DOM by a library such as ReactDOM.\\n\\nWhy was virtual DOM introduced? \\n\\nDOM manipulation is an integral part of any web application, but DOM manipulation is quite slow when compared to other operations in JavaScript. The efficiency of the application gets affected when several DOM manipulations are being done. Most JavaScript frameworks update the entire DOM even when a small part of the DOM changes.\\n\\nFor example, consider a list that is being rendered inside the DOM. If one of the items in the list changes, the entire list gets rendered again instead of just rendering the item that was changed/updated. This is called inefficient updating.\\n\\nTo address the problem of inefficient updating, the react team introduced the concept of virtual DOM.\\n\\nHow does it work?\\n\\nFor every DOM object, there is a corresponding virtual DOM object(copy), which has the same properties. The main difference between the real DOM object and the virtual DOM object is that any changes in the virtual DOM object will not reflect on the screen directly. Consider a virtual DOM object as a blueprint of the real DOM object. Whenever a JSX element gets rendered, every virtual DOM object gets updated.\\n\\n**Note- One may think updating every virtual DOM object might be inefficient, but that’s not the case. Updating the virtual DOM is much faster than updating the real DOM since we are just updating the blueprint of the real DOM.\\n\\nReact uses two virtual DOMs to render the user interface. One of them is used to store the current state of the objects and the other to store the previous state of the objects. Whenever the virtual DOM gets updated, react compares the two virtual DOMs and gets to know about which virtual DOM objects were updated. After knowing which objects were updated, react renders only those objects inside the real DOM instead of rendering the complete real DOM. This way, with the use of virtual DOM, react solves the problem of inefficient updating.\""
    },
    {
        "answer": "\"Controlled and uncontrolled components are just different approaches to handling input from elements in react. \\n\\nFeature\\tUncontrolled\\tControlled\\tName attrs\\nOne-time value retrieval (e.g. on submit)\\t✔️\\t✔️\\t✔️\\nValidating on submit\\t✔️\\t✔️\\t✔️\\nField-level Validation\\t❌\\t✔️\\t✔️\\nConditionally disabling submit button\\t❌\\t✔️\\t✔️\\nEnforcing input format\\t❌\\t✔️\\t✔️\\nseveral inputs for one piece of data\\t❌\\t✔️\\t✔️\\ndynamic inputs\\t❌\\t✔️\\t🤔\\nControlled component: In a controlled component, the value of the input element is controlled by React. We store the state of the input element inside the code, and by using event-based callbacks, any changes made to the input element will be reflected in the code as well.\\n\\nWhen a user enters data inside the input element of a controlled component, onChange function gets triggered and inside the code, we check whether the value entered is valid or invalid. If the value is valid, we change the state and re-render the input element with the new value.\\n\\nExample of a controlled component:\\n\\nfunction FormValidation(props) {\\nlet [inputValue, setInputValue] = useState(\\\"\\\");\\nlet updateInput = e => {\\n  setInputValue(e.target.value);\\n};\\nreturn (\\n  <div>\\n    <form>\\n      <input type=\\\"text\\\" value={inputValue} onChange={updateInput} />\\n    </form>\\n  </div>\\n);\\n}\\n\\nAs one can see in the code above, the value of the input element is determined by the state of the inputValue variable. Any changes made to the input element is handled by the updateInput function.\\n\\nUncontrolled component: In an uncontrolled component, the value of the input element is handled by the DOM itself. Input elements inside uncontrolled components work just like normal HTML input form elements.\\n\\nThe state of the input element is handled by the DOM. Whenever the value of the input element is changed, event-based callbacks are not called. Basically, react does not perform any action when there are changes made to the input element.\\n\\nWhenever use enters data inside the input field, the updated data is shown directly. To access the value of the input element, we can use ref.\\n\\nExample of an uncontrolled component:\\n\\nfunction FormValidation(props) {\\nlet inputValue = React.createRef();\\nlet handleSubmit = e => {\\n  alert(`Input value: ${inputValue.current.value}`);\\n  e.preventDefault();\\n};\\nreturn (\\n  <div>\\n    <form onSubmit={handleSubmit}>\\n      <input type=\\\"text\\\" ref={inputValue} />\\n      <button type=\\\"submit\\\">Submit</button>\\n    </form>\\n  </div>\\n);\\n}\\n\\nAs one can see in the code above, we are not using onChange function to govern the changes made to the input element. Instead, we are using ref to access the value of the input element. \""
    },
    {
        "answer": "\"The props in React are the inputs to a component of React. They can be single-valued or objects having a set of values that will be passed to components of React during creation by using a naming convention that almost looks similar to HTML-tag attributes. We can say that props are the data passed from a parent component into a child component.\\n\\nThe main purpose of props is to provide different component functionalities such as:\\n\\nPassing custom data to the React component.\\nUsing through this.props.reactProp inside render() method of the component.\\nTriggering state changes.\\n\\nFor example, consider we are creating an element with reactProp property as given below: <Element reactProp = \\\"1\\\" />\\nThis reactProp name will be considered as a property attached to the native props object of React which already exists on each component created with the help of React library: props.reactProp;.\""
    },
    {
        "answer": "\"Props\\tState\\nImmutable\\tOwned by its component\\nHas better performance\\tLocally scoped\\nCan be passed to child components\\tWriteable/Mutable\\n \\thas setState() method to modify properties\\n \\tChanges to state can be asynchronous\\n \\tcan only be passed as props\\nReact State\\nEvery component in react has a built-in state object, which contains all the property values that belong to that component.\\nIn other words, the state object controls the behaviour of a component. Any change in the property values of the state object leads to the re-rendering of the component.\\n\\nNote- State object is not available in functional components but, we can use React Hooks to add state to a functional component.\\n\\nHow to declare a state object?\\n\\nExample: \\n\\nclass Car extends React.Component{\\nconstructor(props){\\n  super(props);\\n  this.state = {\\n    brand: \\\"BMW\\\",\\n    color: \\\"black\\\"\\n  }\\n}\\n}\\n\\nHow to use and update the state object?\\n\\nclass Car extends React.Component {\\nconstructor(props) {\\n  super(props);\\n  this.state = {\\n    brand: \\\"BMW\\\",\\n    color: \\\"Black\\\"\\n  };\\n}\\nchangeColor() {\\n  this.setState(prevState => {\\n    return { color: \\\"Red\\\" };\\n  });\\n}\\nrender() {\\n  return (\\n    <div>\\n      <button onClick={() => this.changeColor()}>Change Color</button>\\n      <p>{this.state.color}</p>\\n    </div>\\n  );\\n}\\n}\\n\\nAs one can see in the code above, we can use the state by calling this.state.propertyName and we can change the state object property using setState method.\\n\\nReact Props\\n\\nEvery React component accepts a single object argument called props (which stands for “properties”).  These props can be passed to a component using HTML attributes and the component accepts these props as an argument.\\n\\nUsing props, we can pass data from one component to another.\\n\\nPassing props to a component:\\n\\nWhile rendering a component, we can pass the props as an HTML attribute:\\n\\n<Car brand=\\\"Mercedes\\\"/>\\n\\nThe component receives the props:\\n\\nIn Class component:\\n\\nclass Car extends React.Component {\\nconstructor(props) {\\n  super(props);\\n  this.state = {\\n    brand: this.props.brand,\\n    color: \\\"Black\\\"\\n  };\\n}\\n}\\n\\nIn Functional component:\\n\\nfunction Car(props) {\\nlet [brand, setBrand] = useState(props.brand);\\n}\\n\\nNote- Props are read-only. They cannot be manipulated or changed inside a component.\""
    },
    {
        "answer": "\"There are two types of side effects in React component. They are:\\n\\nEffects without Cleanup: This side effect will be used in useEffect which does not restrict the browser from screen update. It also improves the responsiveness of an application. A few common examples are network requests, Logging, manual DOM mutations, etc.\\nEffects with Cleanup: Some of the Hook effects will require the cleanup after updating of DOM is done. For example, if you want to set up an external data source subscription, it requires cleaning up the memory else there might be a problem of memory leak. It is a known fact that React will carry out the cleanup of memory when the unmounting of components happens. But the effects will run for each render() method rather than for any specific method. Thus we can say that, before execution of the effects succeeding time the React will also cleanup effects from the preceding render.\""
    },
    {
        "answer": "\"Sometimes while developing React applications, there is a need to pass data from a component that is higher in the hierarchy to a component that is deeply nested. To pass data between such components, we pass props from a source component and keep passing the prop to the next component in the hierarchy till we reach the deeply nested component.\\n\\nThe disadvantage of using prop drilling is that the components that should otherwise be not aware of the data have access to the data.\""
    },
    {
        "answer": "\"Introduced in version 16 of React, Error boundaries provide a way for us to catch errors that occur in the render phase.\\n\\nWhat is an error boundary?\\n\\nAny component which uses one of the following lifecycle methods is considered an error boundary.\\nIn what places can an error boundary detect an error?\\n\\nRender phase\\nInside a lifecycle method\\nInside the constructor\\n\\nWithout using error boundaries:\\n\\nclass CounterComponent extends React.Component{\\nconstructor(props){\\n  super(props);\\n  this.state = {\\n    counterValue: 0\\n  }\\n  this.incrementCounter = this.incrementCounter.bind(this);\\n}\\nincrementCounter(){\\n  this.setState(prevState => counterValue = prevState+1);\\n}\\nrender(){\\n  if(this.state.counter === 2){\\n    throw new Error('Crashed');\\n  }\\n  return(\\n    <div>\\n      <button onClick={this.incrementCounter}>Increment Value</button>\\n      <p>Value of counter: {this.state.counterValue}</p>\\n    </div>\\n  )\\n}\\n}\\n\\nIn the code above, when the counterValue equals 2, we throw an error inside the render method.\\n\\nWhen we are not using the error boundary, instead of seeing an error, we see a blank page. Since any error inside the render method leads to unmounting of the component. To display an error that occurs inside the render method, we use error boundaries.\\n\\nWith error boundaries: As mentioned above, error boundary is a component using one or both of the following methods: static getDerivedStateFromError and componentDidCatch.\\n\\nLet’s create an error boundary to handle errors in the render phase:\\n\\nclass ErrorBoundary extends React.Component {\\nconstructor(props) {\\n  super(props);\\n  this.state = { hasError: false };\\n}\\nstatic getDerivedStateFromError(error) {     \\n  return { hasError: true }; \\n}\\n componentDidCatch(error, errorInfo) {       \\n  logErrorToMyService(error, errorInfo); \\n}\\nrender() {\\n  if (this.state.hasError) {     \\n    return <h4>Something went wrong</h4>     \\n  }\\n  return this.props.children;\\n}\\n}\\n\\nIn the code above, getDerivedStateFromError function renders the fallback UI interface when the render method has an error.\\n\\ncomponentDidCatch logs the error information to an error tracking service.\\n\\nNow with the error boundary, we can render the CounterComponent in the following way:\\n\\n<ErrorBoundary>\\n <CounterComponent/>\\n</ErrorBoundary>\""
    },
    {
        "answer": "\"React Hooks are the built-in functions that permit developers for using the state and lifecycle methods within React components. These are newly added features made available in React 16.8 version. Each lifecycle of a component is having 3 phases which include mount, unmount, and update. Along with that, components have properties and states. Hooks will allow using these methods by developers for improving the reuse of code with higher flexibility navigating the component tree.\\n\\nUsing Hook, all features of React can be used without writing class components. For example, before React version 16.8, it required a class component for managing the state of a component. But now using the useState hook, we can keep the state in a functional component.\""
    },
    {
        "answer": "\"What are Hooks? Hooks are functions that let us “hook into” React state and lifecycle features from a functional component.\\n\\nReact Hooks cannot be used in class components. They let us write components without class.\\n\\nWhy were Hooks introduced in React?\\n\\nReact hooks were introduced in the 16.8 version of React. Previously, functional components were called stateless components. Only class components were used for state management and lifecycle methods. The need to change a functional component to a class component, whenever state management or lifecycle methods were to be used, led to the development of Hooks.\\n\\nExample of a hook: useState hook:\\n\\nIn functional components, the useState hook lets us define a state for a component:\\n\\nfunction Person(props) {\\n// We are declaring a state variable called name.\\n// setName is a function to update/change the value of name\\nlet [name, setName] = useState('');\\n}\\n\\nThe state variable “name” can be directly used inside the HTML. \""
    },
    {
        "answer": "\"There are 2 rules which must be followed while you code with Hooks:\\n\\nReact Hooks must be called only at the top level. It is not allowed to call them inside the nested functions, loops, or conditions.\\nIt is allowed to call the Hooks only from the React Function Components.\""
    },
    {
        "answer": "\"The useEffect React Hook is used for performing the side effects in functional components. With the help of useEffect, you will inform React that your component requires something to be done after rendering the component or after a state change. The function you have passed(can be referred to as “effect”) will be remembered by React and call afterwards the performance of DOM updates is over. Using this, we can perform various calculations such as data fetching, setting up document title, manipulating DOM directly, etc, that don’t target the output value. The useEffect hook will run by default after the first render and also after each update of the component. React will guarantee that the DOM will be updated by the time when the effect has run by it.\\n\\nThe useEffect React Hook will accept 2 arguments: useEffect(callback,[dependencies]);\\n\\nWhere the first argument callback represents the function having the logic of side-effect and it will be immediately executed after changes were being pushed to DOM. The second argument dependencies represent an optional array of dependencies. The useEffect() will execute the callback only if there is a change in dependencies in between renderings.\\n\\nExample:\\n\\nimport { useEffect } from 'react';\\nfunction WelcomeGreetings({ name }) {\\n const msg = `Hi, ${name}!`;     // Calculates output\\n useEffect(() => {\\n   document.title = `Welcome to you ${name}`;    // Side-effect!\\n }, [name]);\\n return <div>{msg}</div>;         // Calculates output\\n}\\n\\nThe above code will update the document title which is considered to be a side-effect as it will not calculate the component output directly. That is why updating of document title has been placed in a callback and provided to useEffect().\\n\\nConsider you don’t want to execute document title update each time on rendering of WelcomeGreetings component and you want it to be executed only when the name prop changes then you need to supply name as a dependency to useEffect(callback, [name]).\""
    },
    {
        "answer": "\"Earlier, refs were only limited to class components but now it can also be accessible in function components through the useRef Hook in React.\\n\\nThe refs are used for:\\n\\nManaging focus, media playback, or text selection.\\nIntegrating with DOM libraries by third-party.\\nTriggering the imperative animations.\""
    },
    {
        "answer": "\"A Custom Hook is a function in Javascript whose name begins with ‘use’ and which calls other hooks. It is a part of React v16.8 hook update and permits you for reusing the stateful logic without any need for component hierarchy restructuring.\\n\\nIn almost all of the cases, custom hooks are considered to be sufficient for replacing render props and HoCs (Higher-Order components) and reducing the amount of nesting required. Custom Hooks will allow you for avoiding multiple layers of abstraction or wrapper hell that might come along with Render Props and HoCs.\\n\\nThe disadvantage of Custom Hooks is it cannot be used inside of the classes.\""
    },
    {
        "answer": "\"StrictMode is a tool added in version 16.3 of React to highlight potential problems in an application. It performs additional checks on the application.\\n\\nfunction App() {\\n return (\\n   <React.StrictMode>\\n     <div classname=\\\"App\\\">\\n       <Header/>\\n       <div>\\n         Page Content\\n       </div>\\n       <Footer/>\\n     </div>\\n   </React.StrictMode>\\n );\\n}\\n\\nTo enable StrictMode, <React.StrictMode> tags need to be added inside the application:\\n\\nimport React from \\\"react\\\";\\nimport ReactDOM from \\\"react-dom\\\";\\nimport App from \\\"./App\\\";\\nconst rootElement = document.getElementById(\\\"root\\\");\\nReactDOM.render(\\n<React.StrictMode>\\n  <App />\\n</React.StrictMode>,\\nrootElement\\n);\\n\\nStrictMode currently helps with the following issues:\\n\\nIdentifying components with unsafe lifecycle methods: \\nCertain lifecycle methods are unsafe to use in asynchronous react applications. With the use of third-party libraries, it becomes difficult to ensure that certain lifecycle methods are not used.\\nStrictMode helps in providing us with a warning if any of the class components use an unsafe lifecycle method.\\nWarning about the usage of legacy string API:\\nIf one is using an older version of React, callback ref is the recommended way to manage refs instead of using the string refs. StrictMode gives a warning if we are using string refs to manage refs.\\nWarning about the usage of findDOMNode:\\nPreviously, findDOMNode( ) method was used to search the tree of a DOM node. This method is deprecated in React. Hence, the StrictMode gives us a warning about the usage of this method.\\nWarning about the usage of legacy context API (because the API is error-prone).\""
    },
    {
        "answer": "\"Reason for re-renders in React:\\nRe-rendering of a component and its child components occur when props or the state of the component has been changed.\\nRe-rendering components that are not updated, affects the performance of an application.\\nHow to prevent re-rendering:\\n\\nConsider the following components:\\n\\nclass Parent extends React.Component {\\nstate = { messageDisplayed: false };\\ncomponentDidMount() {\\n  this.setState({ messageDisplayed: true });\\n}\\nrender() {\\n  console.log(\\\"Parent is getting rendered\\\");\\n  return (\\n    <div className=\\\"App\\\">\\n      <Message />\\n    </div>\\n  );\\n}\\n}\\nclass Message extends React.Component {\\nconstructor(props) {\\n  super(props);\\n  this.state = { message: \\\"Hello, this is vivek\\\" };\\n}  \\nrender() {\\n  console.log(\\\"Message is getting rendered\\\");\\n  return (\\n    <div>\\n      <p>{this.state.message}</p>\\n    </div>\\n  );\\n}\\n}\\nThe Parent component is the parent component and the Message is the child component. Any change in the parent component will lead to re-rendering of the child component as well. To prevent the re-rendering of child components, we use the shouldComponentUpdate( ) method:\\n\\n**Note- Use shouldComponentUpdate( ) method only when you are sure that it’s a static component.\\n\\nclass Message extends React.Component {\\nconstructor(props) {\\n  super(props);\\n  this.state = { message: \\\"Hello, this is vivek\\\" };\\n}\\nshouldComponentUpdate() {\\n  console.log(\\\"Does not get rendered\\\");\\n  return false;\\n}\\nrender() {\\n  console.log(\\\"Message is getting rendered\\\");\\n  return (\\n    <div>\\n      <p>{this.state.message}</p>\\n    </div>\\n  );\\n}\\n}\\n\\nAs one can see in the code above, we have returned false from the shouldComponentUpdate( ) method, which prevents the child component from re-rendering. \""
    },
    {
        "answer": "\"There are many different ways through which one can style a React component. Some of the ways are :\\n\\nInline Styling: We can directly style an element using inline style attributes. Make sure the value of style is a JavaScript object:\\nclass RandomComponent extends React.Component {\\n render() {\\n   return (\\n     <div>\\n       <h3 style={{ color: \\\"Yellow\\\" }}>This is a heading</h3>\\n       <p style={{ fontSize: \\\"32px\\\" }}>This is a paragraph</p>\\n     </div>\\n   );\\n }\\n}\\nUsing JavaScript object: We can create a separate JavaScript object and set the desired style properties. This object can be used as the value of the inline style attribute.\\nclass RandomComponent extends React.Component {\\n paragraphStyles = {\\n   color: \\\"Red\\\",\\n   fontSize: \\\"32px\\\"\\n };\\n\\n headingStyles = {\\n   color: \\\"blue\\\",\\n   fontSize: \\\"48px\\\"\\n };\\n\\n render() {\\n   return (\\n     <div>\\n       <h3 style={this.headingStyles}>This is a heading</h3>\\n       <p style={this.paragraphStyles}>This is a paragraph</p>\\n     </div>\\n   );\\n }\\n}\\nCSS Stylesheet: We can create a separate CSS file and write all the styles for the component inside that file. This file needs to be imported inside the component file.\\nimport './RandomComponent.css';\\n\\nclass RandomComponent extends React.Component {\\n render() {\\n   return (\\n     <div>\\n       <h3 className=\\\"heading\\\">This is a heading</h3>\\n       <p className=\\\"paragraph\\\">This is a paragraph</p>\\n     </div>\\n   );\\n }\\n}\\nCSS Modules: We can create a separate CSS module and import this module inside our component. Create a file with “.module.css”‘ extension, styles.module.css:\\n.paragraph{\\n color:\\\"red\\\";\\n border:1px solid black;\\n}\\n\\nWe can import this file inside the component and use it:\\n\\nimport styles from  './styles.module.css';\\n\\nclass RandomComponent extends React.Component {\\n render() {\\n   return (\\n     <div>\\n       <h3 className=\\\"heading\\\">This is a heading</h3>\\n       <p className={styles.paragraph} >This is a paragraph</p>\\n     </div>\\n   );\\n }\\n}\""
    },
    {
        "answer": "\"There are many ways through which one can optimize the performance of a React app, let’s have a look at some of them:\\n\\nUsing useMemo( ) -\\nIt is a React hook that is used for caching CPU-Expensive functions.\\nSometimes in a React app, a CPU-Expensive function gets called repeatedly due to re-renders of a component, which can lead to slow rendering.\\nuseMemo( ) hook can be used to cache such functions. By using useMemo( ), the CPU-Expensive function gets called only when it is needed.\\nUsing React.PureComponent -\\nIt is a base component class that checks the state and props of a component to know whether the component should be updated.\\nInstead of using the simple React.Component, we can use React.PureComponent to reduce the re-renders of a component unnecessarily.\\nMaintaining State Colocation -\\nThis is a process of moving the state as close to where you need it as possible.\\nSometimes in React app, we have a lot of unnecessary states inside the parent component which makes the code less readable and harder to maintain. Not to forget, having many states inside a single component leads to unnecessary re-renders for the component.\\nIt is better to shift states which are less valuable to the parent component, to a separate component.\\nLazy Loading -\\n It is a technique used to reduce the load time of a React app. Lazy loading helps reduce the risk of web app performances to a minimum.\""
    },
    {
        "answer": "\"Parent Component to Child Component (using props)\\n\\nWith the help of props, we can send data from a parent to a child component.\\n\\nHow do we do this?\\n\\nConsider the following Parent Component:\\n\\nimport ChildComponent from \\\"./Child\\\";\\n   function ParentComponent(props) {\\n    let [counter, setCounter] = useState(0);\\n   \\n    let increment = () => setCounter(++counter);\\n   \\n    return (\\n      <div>\\n        <button onClick={increment}>Increment Counter</button>\\n        <ChildComponent counterValue={counter} />\\n      </div>\\n    );\\n   }\\n\\nAs one can see in the code above, we are rendering the child component inside the parent component, by providing a prop called counterValue. The value of the counter is being passed from the parent to the child component.\\n\\nWe can use the data passed by the parent component in the following way:\\n\\nfunction ChildComponent(props) {\\nreturn (\\n  <div>\\n    <p>Value of counter: {props.counterValue}</p>\\n  </div>\\n);\\n}\\n\\nWe use the props.counterValue to display the data passed on by the parent component.\\n\\nChild Component to Parent Component (using callbacks)\\n\\nThis one is a bit tricky. We follow the steps below:\\n\\nCreate a callback in the parent component which takes in the data needed as a parameter.\\nPass this callback as a prop to the child component.\\nSend data from the child component using the callback.\\n\\nWe are considering the same example above but in this case, we are going to pass the updated counterValue from child to parent.\\n\\nStep1 and Step2: Create a callback in the parent component, pass this callback as a prop.\\n\\nfunction ParentComponent(props) {\\nlet [counter, setCounter] = useState(0);\\nlet callback = valueFromChild => setCounter(valueFromChild);\\nreturn (\\n  <div>\\n    <p>Value of counter: {counter}</p>\\n    <ChildComponent callbackFunc={callback} counterValue={counter} />\\n  </div>\\n);\\n}\\n\\nAs one can see in the code above, we created a function called callback which takes in the data received from the child component as a parameter.\\n\\nNext, we passed the function callback as a prop to the child component.\\n\\nStep3: Pass data from the child to the parent component.\\n\\nfunction ChildComponent(props) {\\nlet childCounterValue = props.counterValue;\\nreturn (\\n  <div>\\n    <button onClick={() => props.callbackFunc(++childCounterValue)}>\\n      Increment Counter\\n    </button>\\n  </div>\\n);\\n}\\n\\nIn the code above, we have used the props.counterValue and set it to a variable called childCounterValue.\\n\\nNext, on button click, we pass the incremented childCounterValue to the props.callbackFunc.\\n\\nThis way, we can pass data from the child to the parent component. \""
    },
    {
        "answer": "\"Simply put, Higher-Order Component(HOC) is a function that takes in a component and returns a new component. \\n\\nWhen do we need a Higher Order Component?\\n\\nWhile developing React applications, we might develop components that are quite similar to each other with minute differences. In most cases, developing similar components might not be an issue but, while developing larger applications we need to keep our code DRY, therefore, we want an abstraction that allows us to define this logic in a single place and share it across components. HOC allows us to create that abstraction.\\n\\nExample of a HOC:\\n\\nConsider the following components having similar functionality. The following component displays the list of articles:\\n\\n// \\\"GlobalDataSource\\\" is some global data source\\nclass ArticlesList extends React.Component {\\n constructor(props) {\\n   super(props);\\n   this.handleChange = this.handleChange.bind(this);\\n   this.state = {\\n     articles: GlobalDataSource.getArticles(),\\n   };\\n }\\n componentDidMount() {\\n   // Listens to the changes added\\n   GlobalDataSource.addChangeListener(this.handleChange);\\n }\\n componentWillUnmount() {\\n   // Listens to the changes removed\\n   GlobalDataSource.removeChangeListener(this.handleChange);\\n }\\n handleChange() {\\n   // States gets Update whenver data source changes\\n   this.setState({\\n     articles: GlobalDataSource.getArticles(),\\n   });\\n }\\n render() {\\n   return (\\n     <div>\\n       {this.state.articles.map((article) => (\\n         <ArticleData article={article} key={article.id} />\\n       ))}\\n     </div>\\n   );\\n }\\n}\\n\\nThe following component displays the list of users:\\n\\n// \\\"GlobalDataSource\\\" is some global data source\\nclass UsersList extends React.Component {\\n constructor(props) {\\n   super(props);\\n   this.handleChange = this.handleChange.bind(this);\\n   this.state = {\\n     users: GlobalDataSource.getUsers(),\\n   };\\n }\\n componentDidMount() {\\n   // Listens to the changes added\\n   GlobalDataSource.addChangeListener(this.handleChange);\\n }\\n componentWillUnmount() {\\n   // Listens to the changes removed\\n   GlobalDataSource.removeChangeListener(this.handleChange);\\n }\\n handleChange() {\\n   // States gets Update whenver data source changes\\n   this.setState({\\n     users: GlobalDataSource.getUsers(),\\n   });\\n }\\n render() {\\n   return (\\n     <div>\\n       {this.state.users.map((user) => (\\n         <UserData user={user} key={user.id} />\\n       ))}\\n     </div>\\n   );\\n }\\n}\\n\\nNotice the above components, both have similar functionality but, they are calling different methods to an API endpoint.\\n\\nLet’s create a Higher Order Component to create an abstraction:\\n\\n// Higher Order Component which takes a component\\n// as input and returns another component\\n// \\\"GlobalDataSource\\\" is some global data source\\nfunction HOC(WrappedComponent, selectData) {\\n return class extends React.Component {\\n   constructor(props) {\\n     super(props);\\n     this.handleChange = this.handleChange.bind(this);\\n     this.state = {\\n       data: selectData(GlobalDataSource, props),\\n     };\\n   }\\n   componentDidMount() {\\n     // Listens to the changes added\\n     GlobalDataSource.addChangeListener(this.handleChange);\\n   }\\n   componentWillUnmount() {\\n     // Listens to the changes removed\\n     GlobalDataSource.removeChangeListener(this.handleChange);\\n   }\\n   handleChange() {\\n     this.setState({\\n       data: selectData(GlobalDataSource, this.props),\\n     });\\n   }\\n   render() {\\n     // Rendering the wrapped component with the latest data data\\n     return <WrappedComponent data={this.state.data} {...this.props} />;\\n   }\\n };\\n}\\n\\nWe know HOC is a function that takes in a component and returns a component.\\n\\nIn the code above, we have created a function called HOC which returns a component and performs functionality that can be shared across both the ArticlesList component and UsersList Component.\\n\\nThe second parameter in the HOC function is the function that calls the method on the API endpoint.\\n\\nWe have reduced the duplicated code of the componentDidUpdate and componentDidMount functions.\\n\\nUsing the concept of Higher-Order Components, we can now render the ArticlesList and UsersList components in the following way:\\n\\nconst ArticlesListWithHOC = HOC(ArticlesList, (GlobalDataSource) => GlobalDataSource.getArticles());\\nconst UsersListWithHOC = HOC(UsersList, (GlobalDataSource) => GlobalDataSource.getUsers());\\n\\nRemember, we are not trying to change the functionality of each component, we are trying to share a single functionality across multiple components using HOC. \""
    },
    {
        "answer": "\"There are four different phases in the lifecycle of React component. They are:\\n\\nInitialization: During this phase, React component will prepare by setting up the default props and initial state for the upcoming tough journey.\\nMounting: Mounting refers to putting the elements into the browser DOM. Since React uses VirtualDOM, the entire browser DOM which has been currently rendered would not be refreshed. This phase includes the lifecycle methods componentWillMount and componentDidMount.\\nUpdating: In this phase, a component will be updated when there is a change in the state or props of a component. This phase will have lifecycle methods like componentWillUpdate, shouldComponentUpdate, render, and componentDidUpdate.\\nUnmounting: In this last phase of the component lifecycle, the component will be removed from the DOM or will be unmounted from the browser DOM. This phase will have the lifecycle method named componentWillUnmount.\""
    },
    {
        "answer": "\"React lifecycle hooks will have the methods that will be automatically called at different phases in the component lifecycle and thus it provides good control over what happens at the invoked point. It provides the power to effectively control and manipulate what goes on throughout the component lifecycle.\\n\\nFor example, if you are developing the YouTube application, then the application will make use of a network for buffering the videos and it consumes the power of the battery (assume only these two). After playing the video if the user switches to any other application, then you should make sure that the resources like network and battery are being used most efficiently. You can stop or pause the video buffering which in turn stops the battery and network usage when the user switches to another application after video play.\\n\\nSo we can say that the developer will be able to produce a quality application with the help of lifecycle methods and it also helps developers to make sure to plan what and how to do it at different points of birth, growth, or death of user interfaces.\\n\\nThe various lifecycle methods are:\\n\\nconstructor(): This method will be called when the component is initiated before anything has been done. It helps to set up the initial state and initial values.\\ngetDerivedStateFromProps(): This method will be called just before element(s) rendering in the DOM. It helps to set up the state object depending on the initial props. The getDerivedStateFromProps() method will have a state as an argument and it returns an object that made changes to the state. This will be the first method to be called on an updating of a component.\\nrender(): This method will output or re-render the HTML to the DOM with new changes. The render() method is an essential method and will be called always while the remaining methods are optional and will be called only if they are defined.\\ncomponentDidMount(): This method will be called after the rendering of the component. Using this method, you can run statements that need the component to be already kept in the DOM.\\nshouldComponentUpdate(): The Boolean value will be returned by this method which will specify whether React should proceed further with the rendering or not. The default value for this method will be True.\\ngetSnapshotBeforeUpdate(): This method will provide access for the props as well as for the state before the update. It is possible to check the previously present value before the update, even after the update.\\ncomponentDidUpdate(): This method will be called after the component has been updated in the DOM.\\ncomponentWillUnmount(): This method will be called when the component removal from the DOM is about to happen.\""
    },
    {
        "answer": "\"Static typing refers to the process of code check during the time of compilation for ensuring all variables will be statically typed. React Hooks are functions that are designed to make sure about all attributes must be statically typed. For enforcing stricter static typing within our code, we can make use of the React API with custom Hooks.\""
    },
    {
        "answer": "\"There are two types of Hooks in React. They are:\\n\\n1. Built-in Hooks: The built-in Hooks are divided into 2 parts as given below:\\n\\nBasic Hooks:\\nuseState(): This functional component is used to set and retrieve the state.\\nuseEffect(): It enables for performing the side effects in the functional components.\\nuseContext(): It is used for creating common data that is to be accessed by the components hierarchy without having to pass the props down to each level.\\nAdditional Hooks:\\nuseReducer() : It is used when there is a complex state logic that is having several sub-values or when the upcoming state is dependent on the previous state. It will also enable you to optimization of component performance that will trigger deeper updates as it is permitted to pass the dispatch down instead of callbacks.\\nuseMemo() : This will be used for recomputing the memoized value when there is a change in one of the dependencies. This optimization will help for avoiding expensive calculations on each render.\\nuseCallback() : This is useful while passing callbacks into the optimized child components and depends on the equality of reference for the prevention of unneeded renders.\\nuseImperativeHandle():  It will enable modifying the instance that will be passed with the ref object.\\nuseDebugValue(): It is used for displaying a label for custom hooks in React DevTools.\\nuseRef() : It will permit creating a reference to the DOM element directly within the functional component.\\nuseLayoutEffect(): It is used for the reading layout from the DOM and re-rendering synchronously.\\n\\n2. Custom Hooks: A custom Hook is basically a function of JavaScript. The Custom Hook working is similar to a regular function. The “use” at the beginning of the Custom Hook Name is required for React to understand that this is a custom Hook and also it will describe that this specific function follows the rules of Hooks. Moreover, developing custom Hooks will enable you for extracting component logic from within reusable functions.\""
    },
    {
        "answer": "\"React Hooks\\tClasses\\nIt is used in functional components of React.\\tIt is used in class-based components of React.\\nIt will not require a declaration of any kind of constructor.\\tIt is necessary to declare the constructor inside the class component.\\nIt does not require the use of this keyword in state declaration or modification.\\tKeyword this will be used in state declaration (this.state) and in modification (this.setState()).\\nIt is easier to use because of the useState functionality.\\tNo specific function is available for helping us to access the state and its corresponding setState variable.\\nReact Hooks can be helpful in implementing Redux and context API.\\tBecause of the long setup of state declarations, class states are generally not preferred.\""
    },
    {
        "answer": "\"React Hooks will avoid a lot of overheads such as the instance creation, binding of events, etc., that are present with classes.\\nHooks in React will result in smaller component trees since they will be avoiding the nesting that exists in HOCs (Higher Order Components) and will render props which result in less amount of work to be done by React.\""
    },
    {
        "answer": "\"Our goal is for Hooks to cover all the functionalities for classes at its earliest. There are no Hook equivalents for the following methods that are not introduced in Hooks yet:\\n\\ngetSnapshotBeforeUpdate()\\ngetDerivedStateFromError()\\ncomponentDidCatch()\\n\\nSince it is an early time for Hooks, few third-party libraries may not be compatible with Hooks at present, but they will be added soon.\""
    },
    {
        "answer": "\"React Router refers to the standard library used for routing in React. It permits us for building a single-page web application in React with navigation without even refreshing the page when the user navigates. It also allows to change the browser URL and will keep the user interface in sync with the URL. React Router will make use of the component structure for calling the components, using which appropriate information can be shown. Since React is a component-based framework, it’s not necessary to include and use this package. Any other compatible routing library would also work with React.\\n\\nThe major components of React Router are given below:\\n\\nBrowserRouter: It is a router implementation that will make use of the HTML5 history API (pushState, popstate, and event replaceState) for keeping your UI to be in sync with the URL. It is the parent component useful in storing all other components.\\nRoutes: It is a newer component that has been introduced in the React v6 and an upgrade of the component.\\nRoute: It is considered to be a conditionally shown component and some UI will be rendered by this whenever there is a match between its path and the current URL.\\nLink: It is useful in creating links to various routes and implementing navigation all over the application. It works similarly to the anchor tag in HTML.\""
    },
    {
        "answer": "\"The React Hook cannot be considered as a replacement for Redux (It is an open-source, JavaScript library useful in managing the application state) when it comes to the management of the global application state tree in large complex applications, even though the React will provide a useReducer hook that manages state transitions similar to Redux. Redux is very useful at a lower level of component hierarchy to handle the pieces of a state which are dependent on each other, instead of a declaration of multiple useState hooks.\\n\\nIn commercial web applications which is larger, the complexity will be high, so using only React Hook may not be sufficient. Few developers will try to tackle the challenge with the help of React Hooks and others will combine React Hooks with the Redux.\""
    },
    {
        "answer": "\"Conditional rendering refers to the dynamic output of user interface markups based on a condition state. It works in the same way as JavaScript conditions. Using conditional rendering, it is possible to toggle specific application functions, API data rendering, hide or show elements, decide permission levels, authentication handling, and so on.\\n\\nThere are different approaches for implementing conditional rendering in React. Some of them are:\\n\\nUsing if-else conditional logic which is suitable for smaller as well as for medium-sized applications\\nUsing ternary operators, which takes away some amount of complication from if-else statements\\nUsing element variables, which will enable us to write cleaner code.\""
    },
    {
        "answer": "\"I will assume that you are having some coding knowledge about JavaScript and have installed Node on your system for creating a below given React Hook program. An installation of Node comes along with the command-line tools: npm and npx, where npm is useful to install the packages into a project and npx is useful in running commands of Node from the command line. The npx looks in the current project folder for checking whether a command has been installed there. When the command is not available on your computer, the npx will look in the npmjs.com repository, then the latest version of the command script will be loaded and will run without locally installing it. This feature is useful in creating a skeleton React application within a few key presses.\\n\\nOpen the Terminal inside the folder of your choice, and run the following command:\\n\\nnpx create-react-app react-items-with-hooks\\n\\nHere, the create-react-app is an app initializer created by Facebook, to help with the easy and quick creation of React application, providing options to customize it while creating the application? The above command will create a new folder named react-items-with-hooks and it will be initialized with a basic React application. Now, you will be able to open the project in your favourite IDE. You can see an src folder inside the project along with the main application component App.js. This file is having a single function App() which will return an element and it will make use of an extended JavaScript syntax(JSX) for defining the component.\\n\\nJSX will permit you for writing HTML-style template syntax directly into the JavaScript file. This mixture of JavaScript and HTML will be converted by React toolchain into pure JavaScript that will render the HTML element.\\n\\nIt is possible to define your own React components by writing a function that will return a JSX element. You can try this by creating a new file src/SearchItem.jsand put the following code into it.\\n\\nimport React from 'react';\\nexport function SearchItem() {\\n return (\\n   <div>\\n     <div className=\\\"search-input\\\">\\n       <input type=\\\"text\\\" placeholder=\\\"SearchItem\\\"/>\\n     </div>\\n     <h1 className=\\\"h1\\\">Search Results</h1>\\n     <div className=\\\"items\\\">\\n       <table>\\n         <thead>\\n           <tr>\\n             <th className=\\\"itemname-col\\\">Item Name</th>\\n             <th className=\\\"price-col\\\">Price</th>\\n             <th className=\\\"quantity-col\\\">Quantity</th>\\n           </tr>\\n         </thead>\\n         <tbody></tbody>\\n       </table>\\n     </div>\\n   </div>\\n );\\n}\\n\\nThis is all about how you can create a component. It will only display the empty table and doesn’t do anything. But you will be able to use the Search component in the application. Open the file src/App.js and add the import statement given below to the top of the file.\\n\\nimport { SearchItem } from './SearchItem';\\n\\nNow, from the logo.svg, import will be removed and then contents of returned value in the function App() will be replaced with the following code:\\n\\n<div className=\\\"App\\\">\\n <header>\\n   Items with Hooks\\n </header>\\n <SearchItem/>\\n</div>\\n\\nYou can notice that the element <SearchItem/> has been used just similar to an HTML element. The JSX syntax will enable for including the components in this approach directly within the JavaScript code. Your application can be tested by running the below-given command in your terminal.\\n\\nnpm start\\n\\nThis command will compile your application and open your default browser into http://localhost:4000. This command can be kept on running when code development is in progress to make sure that the application is up-to-date, and also this browser page will be reloaded each time you modify and save the code.\\n\\nThis application will work finely, but it doesn’t look nice as it doesn’t react to any input from the user. You can make it more interactive by adding a state with React Hooks, adding authentication, etc.\""
    },
    {
        "answer": "\"A switching component refers to a component that will render one of the multiple components. We should use an object for mapping prop values to components.\\n\\nA below-given example will show you how to display different pages based on page prop using switching component:\\n\\nimport HomePage from './HomePage'\\nimport AboutPage from './AboutPage'\\nimport FacilitiesPage from './FacilitiesPage'\\nimport ContactPage from './ContactPage'\\nimport HelpPage from './HelpPage'\\nconst PAGES = {\\n home: HomePage,\\n about: AboutPage,\\n facilitiess: FacilitiesPage,\\n contact: ContactPage\\n help: HelpPage\\n}\\nconst Page = (props) => {\\n const Handler = PAGES[props.page] || HelpPage\\n return <Handler {...props} />\\n}\\n// The PAGES object keys can be used in the prop types for catching errors during dev-time.\\nPage.propTypes = {\\n page: PropTypes.oneOf(Object.keys(PAGES)).isRequired\\n}\""
    },
    {
        "answer": "\"It is possible to listen to the resize event in componentDidMount() and then update the width and height dimensions. It requires the removal of the event listener in the componentWillUnmount() method.\\n\\nUsing the below-given code, we can render the view when the browser is resized.\\n\\nclass WindowSizeDimensions extends React.Component {\\n constructor(props){\\n   super(props);\\n   this.updateDimension = this.updateDimension.bind(this);\\n }\\n  \\n componentWillMount() {\\n   this.updateDimension()\\n }\\n componentDidMount() {\\n   window.addEventListener('resize', this.updateDimension)\\n }\\n componentWillUnmount() {\\n   window.removeEventListener('resize', this.updateDimension)\\n }\\n updateDimension() {\\n   this.setState({width: window.innerWidth, height: window.innerHeight})\\n }\\n render() {\\n   return <span>{this.state.width} x {this.state.height}</span>\\n }\\n}\""
    },
    {
        "answer": "\"Passing data between sibling components of React is possible using React Router with the help of history.push and match.params.\\n\\nIn the code given below, we have a Parent component AppDemo.js and have two Child Components HomePage and AboutPage. Everything is kept inside a Router by using React-router Route. It is also having a route for /about/{params} where we will pass the data.\\n\\nimport React, { Component } from ‘react’;\\nclass AppDemo extends Component {\\nrender() {\\n  return (\\n    <Router>\\n      <div className=\\\"AppDemo\\\">\\n      <ul>\\n        <li>\\n          <NavLink to=\\\"/\\\"  activeStyle={{ color:'blue' }}>Home</NavLink>\\n        </li>\\n        <li>\\n          <NavLink to=\\\"/about\\\"  activeStyle={{ color:'blue' }}>About\\n </NavLink>\\n        </li>\\n </ul>\\n             <Route path=\\\"/about/:aboutId\\\" component={AboutPage} />\\n             <Route path=\\\"/about\\\" component={AboutPage} />\\n             <Route path=\\\"/\\\" component={HomePage} />\\n      </div>\\n    </Router>\\n  );\\n}\\n}\\nexport default AppDemo;\\n\\nThe HomePage is a functional component with a button. On button click, we are using props.history.push(‘/about/’ + data) to programmatically navigate into /about/data.\\n\\nexport default function HomePage(props) {\\n const handleClick = (data) => {\\n  props.history.push('/about/' + data);\\n }\\nreturn (\\n  <div>\\n    <button onClick={() => handleClick('DemoButton')}>To About</button>\\n  </div>\\n)\\n}\\n\\nAlso, the functional component AboutPage will obtain the data passed by props.match.params.aboutId.\\n\\nexport default function AboutPage(props) {\\nif(!props.match.params.aboutId) {\\n    return <div>No Data Yet</div>\\n}\\nreturn (\\n  <div>\\n    {`Data obtained from HomePage is ${props.match.params.aboutId}`}\\n  </div>\\n)\\n}\\n\\nAfter button click in the HomePage the page will look like below:\""
    },
    {
        "answer": "\"The react-router package will provide the component <Redirect> in React Router. Rendering of a <Redirect> component will navigate to a newer location. In the history stack, the current location will be overridden by the new location just like the server-side redirects.\\n\\nimport React, { Component } from 'react'\\nimport { Redirect } from 'react-router'\\nexport default class LoginDemoComponent extends Component {\\n render() {\\n   if (this.state.isLoggedIn === true) {\\n     return <Redirect to=\\\"/your/redirect/page\\\" />\\n   } else {\\n     return <div>{'Please complete login'}</div>\\n   }\\n }\\n}\\nConclusion\\n\\nReact has got more popularity among the top IT companies like Facebook, PayPal, Instagram, Uber, etc., around the world especially in India. Hooks is becoming a trend in the React community as it removes the state management complexities.\\n\\nThis article includes the most frequently asked ReactJS and React Hooks interview questions and answers that will help you in interview preparations. Also, remember that your success during the interview is not all about your technical skills, it will also be based on your state of mind and the good impression that you will make at first. All the best!!\\n\\nUseful References and Resources:\\n\\\"Beginning React with Hooks \\\" book by Greg Lim\\n“Learn React Hooks” book by Daniel Bugl\\nNode.js vs React.js\\nReact Native Interview Questions\\nAngular Interview Questions and Answers\""
    }
]


let data = {}

for(let i=0; i<f_qs.length ; i++) {
     data = { ...data , set : f_qs[i]?.question+">>"+f_ans[i]?.answer }

     }

     console.log(data);

// console.log(f_qs.map((ele,index)=>{
//      return {
//          ele.question:f_ans[index].answer
//      }
// }));


 